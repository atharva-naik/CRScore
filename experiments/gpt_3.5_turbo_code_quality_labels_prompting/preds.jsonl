{"pred": "Should add a test to ensure that the parameters are set correctly.", "gold": "can we also test for `transport=rest`?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -53,7 +53,7 @@ public class ProtocGapicPluginGeneratorTest {\n                 model.getFiles().stream().map(ProtoFile::getProto).collect(Collectors.toList()))\n             // Only the file to generate a client for (don't generate dependencies)\n             .addFileToGenerate(\"multiple_services.proto\")\n-            .setParameter(\"language=java\")\n+            .setParameter(\"language=java,transport=grpc\")\n             .build();\n \n     CodeGeneratorResponse response = ProtocGeneratorMain.generate(codeGeneratorRequest);\nCode Quality Aspect: testing\nReview:"}
{"pred": "Is the page size configurable? If not, this should be moved out of the factory and into the constructor of the backend class.", "gold": "If record_batch_size is not set in config.ini, this code will trigger a notice about an undefined value. I would suggest either wrapping the setPageSize() call in an `if (!empty(...)) {` check, or else providing a default value in the set call (i.e. `$config->Index->record_batch_size ?? 100`).", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -182,7 +182,9 @@ abstract class AbstractSolrBackendFactory implements FactoryInterface\n      */\n     protected function createBackend(Connector $connector)\n     {\n+        $config = $this->config->get($this->mainConfig);\n         $backend = new $this->backendClass($connector);\n+        $backend->setPageSize($config->Index->record_batch_size);\n         $backend->setQueryBuilder($this->createQueryBuilder());\n         $backend->setSimilarBuilder($this->createSimilarBuilder());\n         if ($this->logger) {\nCode Quality Aspect: flow\nReview:"}
{"pred": "Should this be NULL checked? Not having the Segment key isn't critical I guess.", "gold": "I didn't realize we were hardcoding this, thanks for moving it to an env value.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1,6 +1,6 @@\n <script type=\"text/javascript\">\n   window.analytics||(window.analytics=[]),window.analytics.methods=[\"identify\",\"track\",\"trackLink\",\"trackForm\",\"trackClick\",\"trackSubmit\",\"page\",\"pageview\",\"ab\",\"alias\",\"ready\",\"group\",\"on\",\"once\",\"off\"],window.analytics.factory=function(t){return function(){var a=Array.prototype.slice.call(arguments);return a.unshift(t),window.analytics.push(a),window.analytics}};for(var i=0;i<window.analytics.methods.length;i++){var method=window.analytics.methods[i];window.analytics[method]=window.analytics.factory(method)}window.analytics.load=function(t){var a=document.createElement(\"script\");a.type=\"text/javascript\",a.async=!0,a.src=(\"https:\"===document.location.protocol?\"https://\":\"http://\")+\"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/\"+t+\"/analytics.min.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(a,n)},window.analytics.SNIPPET_VERSION=\"2.0.8\",\n-  window.analytics.load(\"2nexpdgku3\");\n+  window.analytics.load(<%= ENV['SEGMENT_KEY']%>);\n   window.analytics.page();\n </script>\n \nCode Quality Aspect: expressions\nReview:"}
{"pred": "This could be broken up into a few smaller functions to make it easier to read.", "gold": "We are trying to support IE 10-11, so we'll need a polyfill for this one, I think.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -99,7 +99,7 @@ module.exports = function fileItem (props) {\n         }\n       </h4>\n       <div class=\"UppyDashboardItem-status\">\n-        ${file.data.size && html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`}\n+        ${isNaN(file.data.size) ? '' : html`<div class=\"UppyDashboardItem-statusSize\">${prettyBytes(file.data.size)}</div>`}\n         ${file.source && html`<div class=\"UppyDashboardItem-sourceIcon\">\n             ${acquirers.map(acquirer => {\n               if (acquirer.id === file.source) return html`<span title=\"${props.i18n('fileSource')}: ${acquirer.name}\">${acquirer.icon()}</span>`\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "This could be broken down into smaller functions to make it easier to read and understand.", "gold": "It looks like there's a new `isNavigatingTo( url )` selector for this very purpose so let's use this here instead. This way we just need to use the one selector rather than two. Let's assign that to a similar-named variable here (e.g. `isNavigatingToPostResetURL`) rather than the prop it's used with.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -38,6 +38,9 @@ const { useSelect, useDispatch } = Data;\n function ResetButton( { children } ) {\n \tconst postResetURL = useSelect( ( select ) => select( CORE_SITE ).getAdminURL( 'googlesitekit-splash', { notification: 'reset_success' } ) );\n \n+\tconst isNavigating = useSelect( ( select ) => select( CORE_LOCATION ).isNavigating() );\n+\tconst navigatingURL = useSelect( ( select ) => select( CORE_LOCATION ).getNavigateURL() );\n+\n \tconst [ dialogActive, setDialogActive ] = useState( false );\n \n \tuseEffect( () => {\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "The im2col function is doing too much. It should be broken down into smaller functions that each do one task.", "gold": "I think im2col should only accommodate CPUMat.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -29,8 +29,8 @@\n \n namespace lbann {\n \n-void im2col(const Mat& im,\n-            Mat& col,\n+void im2col(const AbsMat& im,\n+            AbsMat& col,\n             const int num_channels,\n             const int im_num_dims,\n             const int * im_dims,\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "nit: the imports should be grouped by type, i.e. all the Forseti imports should be together, then all the Google Cloud imports, then all the other imports.", "gold": "alpha sort the imports", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -24,6 +24,8 @@ from google.cloud.forseti.notifier.notifiers import cscc_notifier\n from google.cloud.forseti.notifier.notifiers.inventory_summary import InventorySummary\n from google.cloud.forseti.services.inventory.storage import DataAccess\n from google.cloud.forseti.services.scanner import dao as scanner_dao\n+from google.cloud.forseti.common.util.email.email_factory import EmailFactory\n+from google.cloud.forseti.notifier.notifiers import email_violations\n # pylint: enable=line-too-long\n \n \nCode Quality Aspect: layout\nReview:"}
{"pred": "This code could be broken up into smaller functions to make it easier to read and understand.", "gold": "Can you explain why is this necessary? Is `snprintf()` with four integer arguments unsafe?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1067,7 +1067,7 @@ fpga_result mmio_error(struct RASCommandLine *rasCmdLine)\n \tif ( rasCmdLine->function >0 )\n \t\tfunction = rasCmdLine->bus;\n \n-\tsnprintf(sysfs_path, sizeof(sysfs_path),\n+\tsnprintf_s_iiii(sysfs_path, sizeof(sysfs_path),\n \t\t\tDEVICEID_PATH,0,bus,device,function);\n \n \tresult = sysfs_read_u64(sysfs_path, &value);\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "The code is a bit hard to follow, consider breaking it up into smaller functions to make it more readable.", "gold": "How likely would it be that the keyboard layout for the NVDA main thread differs from the keyboard layout of the currently focused app?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -219,7 +219,19 @@ def internal_keyDownEvent(vkCode,scanCode,extended,injected):\n \t\t\tfor k in range(256):\n \t\t\t\tkeyStates[k]=ctypes.windll.user32.GetKeyState(k)\n \t\t\tcharBuf=ctypes.create_unicode_buffer(5)\n+\t\t\t# First try getting the keyboard layout from the thread with the focus (input thread)\n \t\t\thkl=ctypes.windll.user32.GetKeyboardLayout(focus.windowThreadID)\n+\t\t\tif not hkl:\n+\t\t\t\tlog.debug(\"Failed to fetch keyboard layout from focus, trying layout from last detected change\")\n+\t\t\t\t# Some threads, such as for Windows consoles\n+\t\t\t\t# Do not allow getKeyboardLayout to work.\n+\t\t\t\t# Therefore, use the cached keyboard layout from the last inputLangChange detected by NVDA\n+\t\t\t\t# on the foreground object.\n+\t\t\t\thkl = getattr(api.getForegroundObject(), '_lastDetectedKeyboardLayoutChange', 0)\n+\t\t\t\tif not hkl:\n+\t\t\t\t\tlog.debug(\"No layout cached, falling back to layout of NVDA main thread\")\n+\t\t\t\t\t# As a last resort, use the keyboard layout of NVDA's main thread.\n+\t\t\t\t\thkl = ctypes.windll.user32.GetKeyboardLayout(core.mainThreadId)\n \t\t\t# In previous Windows builds, calling ToUnicodeEx would destroy keyboard buffer state and therefore cause the app to not produce the right WM_CHAR message.\n \t\t\t# However, ToUnicodeEx now can take a new flag of 0x4, which stops it from destroying keyboard state, thus allowing us to safely call it here.\n \t\t\tres=ctypes.windll.user32.ToUnicodeEx(vkCode,scanCode,keyStates,charBuf,len(charBuf),0x4,hkl)\nCode Quality Aspect: flow\nReview:"}
{"pred": "This could be broken down into a few smaller functions to make it easier to read and understand.", "gold": "Would you mind removing the default parameter above? (I doubt I'll ever use defaults again since you still have to protect against callers explicitly passing `null` or `undefined`)", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -198,6 +198,10 @@ class Driver extends webdriver.WebDriver {\n    * @return {!Driver} A new driver instance.\n    */\n   static createSession(options, service = getDefaultService()) {\n+    if (!service) {\n+      service = getDefaultService();\n+    }\n+    \n     let client = service.start().then(url => new http.HttpClient(url));\n     let executor = new http.Executor(client);\n \nCode Quality Aspect: decomposition\nReview:"}
{"pred": "NONE", "gold": "Also update line 2205 below", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -2186,7 +2186,7 @@ class WebElement {\n     if (!this.driver_.fileDetector_) {\n       return this.schedule_(\n           new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).\n-              setParameter('text', keys).\n+              setParameter('text', keys.then(keys => keys.join(''))).\n               setParameter('value', keys),\n           'WebElement.sendKeys()');\n     }\nCode Quality Aspect: NONE\nReview:"}
{"pred": "nit: `shared` is a bit vague, maybe `sharedMount` or `sharedMountValue`?", "gold": "n_: It is a good practice to name the variable to indicate what they contain. In this case since `shared` is supposed to have boolean, calling it: `isShared` can help in the readability of the code.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -39,6 +39,7 @@ func (p *Provisioner) ProvisionHostPath(opts pvController.VolumeOptions, volumeC\n \tname := opts.PVName\n \tstgType := volumeConfig.GetStorageType()\n \tsaName := getOpenEBSServiceAccountName()\n+\tshared := volumeConfig.GetSharedMountValue()\n \n \tpath, err := volumeConfig.GetPath()\n \tif err != nil {\nCode Quality Aspect: names\nReview:"}
{"pred": "nit: the comment should mention that the column index is 0-based.", "gold": "I suppose it's a false-positive error. Maybe there is a way to configure the `eslint-*` package to accept `i.e. .... lower case` syntax", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -85,7 +85,10 @@ export class ManualColumnFreeze extends BasePlugin {\n   }\n \n   /**\n-   * Freezes the given column (add it to fixed columns).\n+   * Freezes the specified column (i.e. adds it to fixed columns).\n+   *\n+   * `freezeColumn()` doesn't re-render the table,\n+   * so you need to call the `render()` method afterward.\n    *\n    * @param {number} column Visual column index.\n    */\nCode Quality Aspect: comments\nReview:"}
{"pred": "This could be split into two separate checks for better readability.", "gold": "this maynot be a perf issue, if ToHexString() is not actually allocating a string, but returns the caches string value. to be confirmed.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -133,7 +133,7 @@ namespace OpenTelemetry.Trace\n         private void RunGetRequestedDataOtherSampler(Activity activity)\n         {\n             ActivityContext parentContext;\n-            if (string.IsNullOrEmpty(activity.ParentId))\n+            if (string.IsNullOrEmpty(activity.ParentId) || activity.ParentSpanId.ToHexString().Equals(\"0000000000000000\"))\n             {\n                 parentContext = default;\n             }\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "The code looks a bit cluttered, maybe try to break it up into multiple lines for better readability?", "gold": "`zap.String(\"image-provider\", provider.Name())` should be in a same line.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -114,11 +114,16 @@ func (w *watcher) run(ctx context.Context, provider imageprovider.Provider, inte\n \t\t\t\tupdates = append(updates, u...)\n \t\t\t}\n \t\t\tif len(updates) == 0 {\n-\t\t\t\tw.logger.Info(\"no image to be updated\")\n+\t\t\t\tw.logger.Info(\"no image to be updated\",\n+\t\t\t\t\tzap.String(\"image-provider\", provider.Name()),\n+\t\t\t\t)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif err := update(updates); err != nil {\n-\t\t\t\tw.logger.Error(\"failed to update image\", zap.Error(err))\n+\t\t\t\tw.logger.Error(\"failed to update image\", zap.String(\"image-provider\",\n+\t\t\t\t\tprovider.Name()),\n+\t\t\t\t\tzap.Error(err),\n+\t\t\t\t)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\nCode Quality Aspect: layout\nReview:"}
{"pred": "N/A", "gold": "Why this deletion?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1,8 +1,6 @@\n /*exported DqElement */\n \n function truncate(str, maxLength) {\n-\t'use strict';\n-\n \tmaxLength = maxLength || 300;\n \n \tif (str.length > maxLength) {\nCode Quality Aspect: NONE\nReview:"}
{"pred": "N/A", "gold": "This change looks unrelated to the CL description?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -419,7 +419,10 @@ class S3KeyTest(unittest.TestCase):\n         remote_metadata = check._get_remote_metadata()\n \n         # TODO: investigate whether encoding ' ' as '%20' makes sense\n-        self.assertEqual(check.cache_control, 'public,%20max-age=500')\n+        self.assertIn(\n+            check.cache_control,\n+            ('public,%20max-age=500', 'public, max-age=500')\n+        )\n         self.assertEqual(remote_metadata['cache-control'], 'public,%20max-age=500')\n         self.assertEqual(check.get_metadata('test-plus'), 'A plus (+)')\n         self.assertEqual(check.content_disposition, 'filename=Sch%C3%B6ne%20Zeit.txt')\nCode Quality Aspect: NONE\nReview:"}
{"pred": "Consider breaking this macro into multiple lines for readability.", "gold": "I'm not certain that `res`+`utl` isn't a thing.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -18,7 +18,7 @@ class DedupTest : public QueryTestBase {\n   void SetUp() override { QueryTestBase::SetUp(); }\n };\n \n-#define DEDUP_RESUTL_CHECK(inputName, outputName, sentence, expected)                   \\\n+#define DEDUP_RESULT_CHECK(inputName, outputName, sentence, expected)                   \\\n   do {                                                                                  \\\n     qctx_->symTable()->newVariable(outputName);                                         \\\n     auto yieldSentence = getYieldSentence(sentence, qctx_.get());                       \\\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "This query should be broken down into smaller parts and then combined.", "gold": "This method can cause bugs. Why don't you use list of finalize statuses and then use join by comma and that will give you correct value. Use Apache Commons Lang library List<Integer> list = Arrays.asList(1,2,3,4,5,6,7); String str = org.apache.commons.lang.StringUtils.join(list, \",\"); You can use it at multiple places shown in this diff.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -182,6 +182,7 @@ public class FetchActiveFlowDao {\n             + \" LEFT JOIN \"\n             + \" executors et ON ex.executor_id = et.id\"\n             + \" WHERE ex.status NOT IN (\"\n+            + Status.EXECUTION_STOPPED.getNumVal() + \", \"\n             + Status.SUCCEEDED.getNumVal() + \", \"\n             + Status.KILLED.getNumVal() + \", \"\n             + Status.FAILED.getNumVal() + \")\";\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "Should this have an else clause?", "gold": "Merge with next condition", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -23,7 +23,10 @@ void wlr_input_device_init(struct wlr_input_device *dev,\n }\n \n void wlr_input_device_destroy(struct wlr_input_device *dev) {\n-\tif (!dev) return;\n+\tif (!dev) {\n+\t\treturn;\n+\t}\n+\t\n \tif (dev->_device) {\n \t\tswitch (dev->type) {\n \t\tcase WLR_INPUT_DEVICE_KEYBOARD:\nCode Quality Aspect: flow\nReview:"}
{"pred": "Should the DeleteTask() method be called before the DeployTask() method?", "gold": "Maybe add it when it is used.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -348,6 +348,7 @@ type appResourcesGetter interface {\n \n type taskDeployer interface {\n \tDeployTask(input *deploy.CreateTaskResourcesInput, opts ...cloudformation.StackOption) error\n+\tDeleteTask(task deploy.TaskStackInfo) error\n }\n \n type taskRunner interface {\nCode Quality Aspect: flow\nReview:"}
{"pred": "nit: `NONEXIST_ENABLED` vs. `ALL_EXIST` looks like a naming inconsistency?", "gold": "More clear naming: NONEXISTENT_ENABLED", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -36,3 +36,17 @@ TWO_ENABLED = {'scanners': [\n     {'name': 'cloudsql_acl', 'enabled': False},\n     {'name': 'iam_policy', 'enabled': True}\n ]}\n+\n+NONEXIST_ENABLED = {'scanners': [\n+    {'name': 'bigquery', 'enabled': False},\n+    {'name': 'bucket_acl', 'enabled': True},\n+    {'name': 'cloudsql_acl', 'enabled': False},\n+    {'name': 'non_exist_scanner', 'enabled': True}\n+]}\n+\n+ALL_EXIST = {'scanners': [\n+    {'name': 'bigquery', 'enabled': True},\n+    {'name': 'bucket_acl', 'enabled': True},\n+    {'name': 'cloudsql_acl', 'enabled': True},\n+    {'name': 'iam_policy', 'enabled': True}\n+]}\nCode Quality Aspect: names\nReview:"}
{"pred": "N/A", "gold": "why is this change necessary?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -282,10 +282,10 @@ public class TypeUtil {\n \n     switch (from.typeId()) {\n       case INTEGER:\n-        return to == Types.LongType.get();\n+        return to.equals(Types.LongType.get());\n \n       case FLOAT:\n-        return to == Types.DoubleType.get();\n+        return to.equals(Types.DoubleType.get());\n \n       case DECIMAL:\n         Types.DecimalType fromDecimal = (Types.DecimalType) from;\nCode Quality Aspect: NONE\nReview:"}
{"pred": "Consider making a helper method for this logic, so it can be reused in other places.", "gold": "make a SchemaTypeNameConverter.getTypeNameForEmptyType() and call that here.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -178,9 +178,8 @@ public class SchemaTypeTable implements ImportTypeTable, SchemaTypeFormatter {\n \n   @Override\n   public String getFullNameFor(TypeModel type) {\n-    // TODO(andrealin): Remove this hack when null response types are implemented.\n-    if (type == null) {\n-      return \"nullFullName\";\n+    if (type.isEmptyType()) {\n+      return \"java.lang.Void\";\n     }\n     if (type instanceof DiscoveryRequestType) {\n       Method method = ((DiscoveryRequestType) type).parentMethod().getDiscoMethod();\nCode Quality Aspect: modularization\nReview:"}
{"pred": "The indentation of the else statement should be aligned with the if statement.", "gold": "Use braces on your conditional structures please", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -26,7 +26,10 @@ class TinyMCELanguage extends AbstractSmartyPlugin\n \n     public function __construct(Request $request)\n     {\n-        $this->locale = $request->getSession()->getLang()->getLocale();\n+        if($request->getSession() != null)\n+            $this->locale = $request->getSession()->getLang()->getLocale();\n+        else\n+            $this->locale = Lang::getDefaultLanguage()->getLocale();\n     }\n \n     public function guessTinyMCELanguage($params, \\Smarty_Internal_Template $template)\nCode Quality Aspect: formatting\nReview:"}
{"pred": "Should this be NULL checked? Not having the name isn't critical I guess.", "gold": "Great God, I have a question. This \".nebula_history\" file is used to save history commands. Is there a file size limit? When the file is large, does it take a long time to start initialization (loadHistory)? How did you think about this? Thx.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -16,6 +16,7 @@\n \n DECLARE_string(u);\n DECLARE_string(p);\n+DEFINE_bool(enable_history, false, \"Whether to force saving the command history\");\n \n namespace nebula {\n namespace graph {\nCode Quality Aspect: expressions\nReview:"}
{"pred": "Should this be NULL checked? Not having the name isn't critical I guess.", "gold": "Isn't this the same check as two lines above?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1004,8 +1004,9 @@ static void parseRecord (tokenInfo *const token)\n \t */\n \tif (!isType (token, TOKEN_OPEN_PAREN))\n \t\treadToken (token);\n+\tif (!isType (token, TOKEN_OPEN_PAREN))\n+\t\treturn;\n \n-\tAssert (isType (token, TOKEN_OPEN_PAREN));\n \tdo\n \t{\n \t\tif (isType (token, TOKEN_COMMA) ||\nCode Quality Aspect: expressions\nReview:"}
{"pred": "This looks like a good candidate for a helper method.", "gold": "Don't redefine, just import the existing one in `cmdline.py`. :)", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -18,8 +18,11 @@ from mitmproxy import io\n from mitmproxy import log\n from mitmproxy import version\n from mitmproxy import optmanager\n+from mitmproxy import options\n import mitmproxy.tools.web.master # noqa\n \n+CONFIG_PATH = os.path.join(options.CA_DIR, 'config.yaml')\n+\n \n def flow_to_json(flow: mitmproxy.flow.Flow) -> dict:\n     \"\"\"\nCode Quality Aspect: modularization\nReview:"}
{"pred": "This looks like it could be simplified by inverting the aliased_fields before the if statement, so that the respond_to? check is only done once.", "gold": "why not call `respond_to?(\"#{name}=\")` from the `if` line?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -92,7 +92,8 @@ module Mongoid\n       #\n       # @since 2.0.0.rc.7\n       def process_attribute(name, value)\n-        if store_as = aliased_fields.invert[name.to_s]\n+        responds = respond_to?(\"#{name}=\")\n+        if !responds && store_as = aliased_fields.invert[name.to_s]\n           name = store_as\n         end\n         responds = respond_to?(\"#{name}=\")\nCode Quality Aspect: flow\nReview:"}
{"pred": "Should the workingDir be NULL checked?", "gold": "This was properly set above as `<target>.runfiles/<workspace_name>` (with a fallback to workspace root dir) but never used past this line.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -215,7 +215,8 @@ public final class BlazeCidrLauncher extends CidrLauncher {\n         workingDir = workspaceRootDirectory;\n       }\n \n-      GeneralCommandLine commandLine = new GeneralCommandLine(runner.executableToDebug.getPath());\n+      GeneralCommandLine commandLine = new GeneralCommandLine(runner.executableToDebug.getPath())\n+          .withWorkDirectory(workingDir);\n \n       commandLine.addParameters(handlerState.getExeFlagsState().getFlagsForExternalProcesses());\n       commandLine.addParameters(handlerState.getTestArgs());\nCode Quality Aspect: expressions\nReview:"}
{"pred": "N/A", "gold": "Are all these namespaces required for this attribute?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -0,0 +1,13 @@\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+using System.Threading.Tasks;\n+using MvvmCross.Core.Views;\n+\n+namespace MvvmCross.Uwp.Attributes\n+{\n+    public class MvxPagePresentationAttribute : MvxBasePresentationAttribute\n+    {\n+    }\n+}\nCode Quality Aspect: NONE\nReview:"}
{"pred": "Maybe break this into separate methods for logging stdout, stderr, and exceptions?", "gold": "Given this may be used and printed in other ways, isn't `debug` more appropriate?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -53,9 +53,12 @@ module Beaker\n           result.stdout << std_out\n           result.stderr << std_err\n           result.exit_code = status.exitstatus\n+          @logger.info(result.stdout)\n+          @logger.info(result.stderr)\n         end\n       rescue => e\n         result.stderr << e.inspect\n+        @logger.info(result.stderr)\n         result.exit_code = 1\n       end\n \nCode Quality Aspect: decomposition\nReview:"}
{"pred": "Should this be a separate method? It's a bit different from the other methods in the blockDiskStore.", "gold": "Looks like this is unused? Did you mean to call it when clearing the block journal?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -540,3 +540,7 @@ func (s *blockDiskStore) remove(id kbfsblock.ID) error {\n \t}\n \treturn err\n }\n+\n+func (s blockDiskStore) clear() error {\n+\treturn ioutil.RemoveAll(s.dir)\n+}\nCode Quality Aspect: flow\nReview:"}
{"pred": "nit: `alters` vs. `alerters` looks like a naming inconsistency?", "gold": "why named alters? how about this.alerts = alerts?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -117,8 +117,10 @@ public class ExecutorManager extends EventHandler implements\n \n   public ExecutorManager(Props props, ExecutorLoader loader,\n       Map<String, Alerter> alters) throws ExecutorManagerException {\n+    alerters = alters;\n     azkProps = props;\n     this.executorLoader = loader;\n+\n     this.setupExecutors();\n     this.loadRunningFlows();\n \nCode Quality Aspect: names\nReview:"}
{"pred": "N/A", "gold": "not sure if this has to be here or not tbh", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1549,7 +1549,7 @@ func (js *jetStream) processStreamLeaderChange(mset *stream, isLeader bool) {\n \t\tresp.Error = jsError(err)\n \t\ts.sendAPIErrResponse(client, acc, subject, reply, _EMPTY_, s.jsonResponse(&resp))\n \t} else {\n-\t\tresp.StreamInfo = &StreamInfo{Created: mset.createdTime(), State: mset.state(), Config: mset.config(), Cluster: js.clusterInfo(mset.raftGroup())}\n+\t\tresp.StreamInfo = &StreamInfo{Created: mset.createdTime(), State: mset.state(), Config: mset.config(), Cluster: js.clusterInfo(mset.raftGroup()), Sources: mset.sourcesInfo(), Mirror: mset.mirrorInfo()}\n \t\ts.sendAPIResponse(client, acc, subject, reply, _EMPTY_, s.jsonResponse(&resp))\n \t\tif node := mset.raftNode(); node != nil {\n \t\t\tmset.sendCreateAdvisory()\nCode Quality Aspect: NONE\nReview:"}
{"pred": "NONE", "gold": "There's a better fix for this in #1741, which should replace this.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -72,7 +72,12 @@ func newHarnessUsingAutodelete(ctx context.Context, t *testing.T) (drivertest.Ha\n }\n \n func (h *harness) CreateTopic(ctx context.Context, testName string) (dt driver.Topic, cleanup func(), err error) {\n+\t// Keep the topic entity name under 50 characters as per Azure limits.\n+\t// See https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-quotas\n \ttopicName := fmt.Sprintf(\"%s-topic-%d\", sanitize(testName), atomic.AddUint32(&h.numTopics, 1))\n+\tif len(topicName) > 50 {\n+\t\ttopicName = topicName[:50]\n+\t}\n \n \tcreateTopic(ctx, topicName, h.ns, nil)\n \nCode Quality Aspect: NONE\nReview:"}
{"pred": "Should this be NULL checked? Not having the address isn't critical I guess.", "gold": "Use swarm.Address not []byte as type, and construct it from actual byteslice or use swarm.NewAddress if it is constructed from hex-encoded string.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -63,7 +63,7 @@ func (s *StreamMock) Close() error {\n func TestHandshake(t *testing.T) {\n \tlogger := logging.New(ioutil.Discard, 0)\n \tinfo := Info{\n-\t\tAddress:   \"node1\",\n+\t\tAddress:   []byte(\"node1\"),\n \t\tNetworkID: 0,\n \t\tLight:     false,\n \t}\nCode Quality Aspect: expressions\nReview:"}
{"pred": "Consider breaking this up into multiple tests, one for each step. This will make it easier to debug and maintain.", "gold": "It would be worth factoring this out to a function, but you don't have to do that here.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -80,8 +80,9 @@ func TestFSRepoInit(t *testing.T) {\n \n \tdir, err := ioutil.TempDir(\"\", \"\")\n \tassert.NoError(t, err)\n-\n-\tdefer os.RemoveAll(dir)\n+\tdefer func() {\n+\t\trequire.NoError(t, os.RemoveAll(dir))\n+\t}()\n \n \tt.Log(\"init FSRepo\")\n \tassert.NoError(t, InitFSRepo(dir, config.NewDefaultConfig()))\nCode Quality Aspect: decomposition\nReview:"}
{"pred": "This looks like a well-structured and modularized code. Good job!", "gold": "There's no need for `final` in interfaces.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -0,0 +1,15 @@\n+package com.fsck.k9.message.html;\n+\n+/**\n+ * General framework to handle uris when parsing. Allows different handling depending on the scheme identifier.\n+ */\n+public interface UriParser {\n+    /**\n+     * Parse and linkify scheme specific uri beginning from given position. The result will be written to given buffer.\n+     * @param text String to parse uri from.\n+     * @param startPos Position where uri starts (first letter of scheme).\n+     * @param outputBuffer Buffer where linkified variant of uri is written to.\n+     * @return Index where parsed uri ends (first non-uri letter). Should be startPos or smaller if no valid uri was found.\n+     */\n+    int linkifyUri(String text, int startPos, StringBuffer outputBuffer);\n+}\nCode Quality Aspect: modularization\nReview:"}
{"pred": "Consider making a separate method for setting the service version tag.", "gold": "Isn't this case handled as a custom tag in `Span.SetTag()` below? This switch is only for special tags that actually set `Span` properties.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -101,6 +101,9 @@ namespace Datadog.Trace.OpenTracing\n                 case DatadogTags.ServiceName:\n                     Span.ServiceName = value;\n                     return this;\n+                case DatadogTags.ServiceVersion:\n+                    Span.SetTag(Tags.Version, value);\n+                    return this;\n             }\n \n             if (key == global::OpenTracing.Tag.Tags.Error.Key)\nCode Quality Aspect: modularization\nReview:"}
{"pred": "N/A", "gold": "This shouldn't be changed.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -681,7 +681,6 @@ class Quitter:\n     @cmdutils.argument('session', completion=miscmodels.session)\n     def quit(self, save=False, session=None):\n         \"\"\"Quit qutebrowser.\n-\n         Args:\n             save: When given, save the open windows even if auto_save.session\n                   is turned off.\nCode Quality Aspect: NONE\nReview:"}
{"pred": "The comment should be updated to reflect the new year.", "gold": "This one is important `2: I102 copyright year is outdated, expected 2014 but got 2012`", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -1,5 +1,5 @@\n ## This file is part of Invenio.\n-## Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 CERN.\n+## Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2014 CERN.\n ##\n ## Invenio is free software; you can redistribute it and/or\n ## modify it under the terms of the GNU General Public License as\nCode Quality Aspect: comments\nReview:"}
{"pred": "Consider using a functional interface instead of a Consumer/BiConsumer for better modularization.", "gold": "Are these imports needed (BiConsumer and Consumer)? If they are unused imports, then precommit will fail.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -32,6 +32,8 @@ import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\nCode Quality Aspect: modularization\nReview:"}
{"pred": "Should this be a `before_destroy` callback on the trace model instead?", "gold": "Why are we catching and logging exceptions? By doing that we make it look like the job has succeeded and it will be removed from the queue - if we didn't do that then it would stay queued...", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -0,0 +1,10 @@\n+class TraceDestroyerJob < ApplicationJob\n+  queue_as :default\n+\n+  def perform(trace)\n+    trace.destroy\n+  rescue StandardError => ex\n+    logger.info ex.to_s\n+    ex.backtrace.each { |l| logger.info l }\n+  end\n+end\nCode Quality Aspect: flow\nReview:"}
{"pred": "nit: the comment for the indexAction method is outdated.", "gold": "If there are `@param` tags in docblock, there should be `@return` tag also. (applies for a whole file)", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -90,14 +90,11 @@ class CartController extends FrontBaseController\n      */\n     public function indexAction(Request $request)\n     {\n-        $cart = $this->cartFacade->getCartOfCurrentCustomer();\n-\n-        if ($cart->isEmpty()) {\n-            $this->cartFacade->cleanAdditionalData();\n-        }\n+        $cart = $this->cartFacade->findCartOfCurrentCustomer();\n+        $cartItems = $cart === null ? [] : $cart->getItems();\n \n         $cartFormData = ['quantities' => []];\n-        foreach ($cart->getItems() as $cartItem) {\n+        foreach ($cartItems as $cartItem) {\n             $cartFormData['quantities'][$cartItem->getId()] = $cartItem->getQuantity();\n         }\n \nCode Quality Aspect: comments\nReview:"}
{"pred": "Maybe add a comment to explain why validators is a separate category?", "gold": "Is the concept of validators exclusive to IBFT2? I wonder if this category should be more explicitly linked to IBFT2.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -34,7 +34,8 @@ public enum BesuMetricCategory implements MetricCategory {\n   PRUNER(\"pruner\"),\n   RPC(\"rpc\"),\n   SYNCHRONIZER(\"synchronizer\"),\n-  TRANSACTION_POOL(\"transaction_pool\");\n+  TRANSACTION_POOL(\"transaction_pool\"),\n+  VALIDATORS(\"validators\");\n \n   private static final Optional<String> BESU_PREFIX = Optional.of(\"besu_\");\n   public static final Set<MetricCategory> DEFAULT_METRIC_CATEGORIES;\nCode Quality Aspect: modularization\nReview:"}
{"pred": "nit: formatting looks a bit off here, could use some extra newlines between imports.", "gold": "Spotless is configured to reject star imports. Please replace with explicit imports.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -14,9 +14,7 @@\n  */\n package org.hyperledger.besu.tests.acceptance.dsl.account;\n \n-import org.hyperledger.besu.crypto.SECP256K1.KeyPair;\n-import org.hyperledger.besu.crypto.SECP256K1.PrivateKey;\n-import org.hyperledger.besu.crypto.SECP256K1.PublicKey;\n+import org.hyperledger.besu.crypto.*;\n import org.hyperledger.besu.ethereum.core.Address;\n import org.hyperledger.besu.ethereum.core.Hash;\n import org.hyperledger.besu.tests.acceptance.dsl.blockchain.Amount;\nCode Quality Aspect: formatting\nReview:"}
{"pred": "The variable names could be more descriptive (e.g. `maxThreadsPerSM` vs. `maxShmemPerBlock`).", "gold": "Remind me why you are using CUDA vocabulary when naming these variables.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -115,6 +115,8 @@ void SYCLInternal::initialize(const sycl::device& d) {\n \n     m_maxThreadsPerSM =\n         d.template get_info<sycl::info::device::max_work_group_size>();\n+    m_maxShmemPerBlock =\n+        d.template get_info<sycl::info::device::local_mem_size>();\n     m_indirectKernelMem.reset(*m_queue);\n     m_indirectReducerMem.reset(*m_queue);\n   } else {\nCode Quality Aspect: names\nReview:"}
{"pred": "This looks like it could be refactored into a separate method to make the flow easier to follow.", "gold": "Please turn the iteration order around (instead of `0...size` to `size...0`). The reason is that this sometimes skips indices when removing an item. You can therefore end up with feeds that have counter 0 and are still displayed.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -898,6 +898,16 @@ public final class DBReader {\n         }\n         final LongIntMap feedCounters = adapter.getFeedCounters(feedIds);\n \n+        int feedFilter = UserPreferences.getFeedFilter();\n+        if (feedFilter == UserPreferences.FEED_FILTER_COUNTER_ZERO) {\n+            for (int i = 0; i < feeds.size(); i++) {\n+                if (feedCounters.get(feeds.get(i).getId()) <= 0) {\n+                    feedCounters.delete(feeds.get(i).getId());\n+                    feeds.remove(i);\n+                }\n+            }\n+        }\n+\n         Comparator<Feed> comparator;\n         int feedOrder = UserPreferences.getFeedOrder();\n         if (feedOrder == UserPreferences.FEED_ORDER_COUNTER) {\nCode Quality Aspect: flow\nReview:"}
{"pred": "The expression can be simplified to `return pipeline if solid_subset else build_sub_pipeline(pipeline, solid_subset)`", "gold": "this is a behavior change. solid_subset=[] represents an empty pipeline where as solid_subset=None is the full pipeline", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -620,7 +620,7 @@ def execute_reentrant_pipeline(pipeline, typed_environment, throw_on_error, reen\n def get_subset_pipeline(pipeline, solid_subset):\n     check.inst_param(pipeline, 'pipeline', PipelineDefinition)\n     check.opt_list_param(solid_subset, 'solid_subset', of_type=str)\n-    return pipeline if solid_subset is None else build_sub_pipeline(pipeline, solid_subset)\n+    return pipeline if not solid_subset else build_sub_pipeline(pipeline, solid_subset)\n \n \n def create_typed_environment(pipeline, environment=None):\nCode Quality Aspect: expressions\nReview:"}
{"pred": "N/A", "gold": "this is a breaking change, any specific reason you want to do this?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -318,8 +318,7 @@ Licensed under the MIT License. See License.txt in the project root for license\n             {\n                 foreach (var unmatchedSetting in CustomSettings.Keys)\n                 {\n-                    Logger.LogError(new ArgumentException(unmatchedSetting),\n-                        Resources.ParameterIsNotValid, unmatchedSetting);\n+                    Logger.LogWarning(Resources.ParameterIsNotValid, unmatchedSetting);\n                 }\n             }\n             ErrorManager.ThrowErrors();\nCode Quality Aspect: NONE\nReview:"}
{"pred": "Should PutTipSetAndState and SetHead be split into separate interfaces?", "gold": "Blocking: we still want read write separation. Node functions should absolutely not write to the chain store and the interface should reflect that. Only the syncer should have this capability in production code. It should be no problem to keep casting chainForTest to a read-write interface, or doing other function decomposition and automatic casting tricks.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -91,6 +91,8 @@ type nodeChainReader interface {\n \tGetTipSetStateRoot(tsKey types.SortedCidSet) (cid.Cid, error)\n \tHeadEvents() *ps.PubSub\n \tLoad(context.Context) error\n+\tPutTipSetAndState(context.Context, *chain.TipSetAndState) error\n+\tSetHead(context.Context, types.TipSet) error\n \tStop()\n }\n \nCode Quality Aspect: modularization\nReview:"}
{"pred": "Should the defaultOnDemandRequestPriority be checked for overflow?", "gold": "The PR description says the lowest on-demand request priority is `2^30`. Why the `-1` here?", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -22,7 +22,8 @@ const (\n \tminimalPrefetchWorkerQueueSize       int = 1\n \ttestBlockRetrievalWorkerQueueSize    int = 5\n \ttestPrefetchWorkerQueueSize          int = 1\n-\tdefaultOnDemandRequestPriority       int = 100\n+\tdefaultOnDemandRequestPriority       int = 1<<30 - 1\n+\tlowestTriggerPrefetchPriority        int = 1\n \t// Channel buffer size can be big because we use the empty struct.\n \tworkerQueueSize int = 1<<31 - 1\n )\nCode Quality Aspect: expressions\nReview:"}
{"pred": "Should this be NULL checked? Not having the creature isn't critical I guess.", "gold": "checking health again? I think it is not necessary.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -609,6 +609,14 @@ bool Game::removeCreature(Creature* creature, bool isLogout/* = true*/)\n \treturn true;\n }\n \n+void Game::executeDeath(uint32_t creatureId)\n+{\n+\tCreature* creature = getCreatureByID(creatureId);\n+\tif (creature && !creature->isRemoved() && creature->getHealth() < 1) {\n+\t\tcreature->onDeath();\n+\t}\n+}\n+\n void Game::playerMoveThing(uint32_t playerId, const Position& fromPos,\n                            uint16_t spriteId, uint8_t fromStackPos, const Position& toPos, uint8_t count)\n {\nCode Quality Aspect: expressions\nReview:"}
{"pred": "Should this be NULL checked? Not having the name isn't critical I guess.", "gold": "Need an `if err == nil {break}` above this line so that we don't log/sleep if the retry succeeds.", "prompt": "Look at the given code changes and code quality aspects and generate the code reviews:\n\nCode Change: @@ -587,6 +587,8 @@ static void *evp_md_from_dispatch(const OSSL_DISPATCH *fns,\n     if ((md = EVP_MD_meth_new(NID_undef, NID_undef)) == NULL)\n         return NULL;\n \n+    md->name = OPENSSL_strdup(name);\n+\n     for (; fns->function_id != 0; fns++) {\n         switch (fns->function_id) {\n         case OSSL_FUNC_DIGEST_NEWCTX:\nCode Quality Aspect: expressions\nReview: Should this be NULL checked? Not having the name isn't critical I guess.\n\nCode Change: @@ -25,13 +25,16 @@ module View\n       def should_render_revenue?\n         revenue = @tile.revenue_to_render\n\n+        # special case: city with multi-revenue - no choice but to draw separate revenue\n+        return true if revenue.any? { |r| !r.is_a?(Numeric) }\n+\n         return false if revenue.empty?\n\n         return false if revenue.first.is_a?(Numeric) && (@tile.cities + @tile.towns).one?\n\n         return false if revenue.uniq.size > 1\n\n-        return false if @tile.cities.sum(&:slots) < 3 && @tile.stops.size == 2\n+        return false if @tile.cities.sum(&:slots) < 3 && (@tile.cities + @tile.towns).size == 2\n\n         true\n       end\nCode Quality Aspect: modularization\nReview: we call cities + towns . size a lot, maybe make a helper method on tiles\n\nCode Change: @@ -160,6 +160,11 @@ func (r *routeBuilder) profileHandler() (request.Handler, error) {\n        return middleware.Wrap(h, backendMiddleware(r.cfg, r.authenticator, r.ratelimitStore, profile.MonitoringMap)...)\n }\n\n+func (r *routeBuilder) firehoseLogHandler() (request.Handler, error) {\n+       h := firehose.Handler(r.batchProcessor, r.authenticator)\n+       return middleware.Wrap(h, firehoseMiddleware(r.cfg, intake.MonitoringMap)...)\n+}\n+\n func (r *routeBuilder) backendIntakeHandler() (request.Handler, error) {\n        requestMetadataFunc := emptyRequestMetadata\n        if r.cfg.AugmentEnabled {\nCode Quality Aspect: names\nReview: nit: `firehoseLogHandler` vs. `firehoseMiddleware` looks like a naming inconsistency? (`log` is not used anywhere else).\nCode Change: @@ -442,7 +442,18 @@ configRetry:\n \t\tlog.Infof(\"Starting the Typha connection\")\n \t\terr := typhaConnection.Start(context.Background())\n \t\tif err != nil {\n-\t\t\tlog.WithError(err).Fatal(\"Failed to connect to Typha\")\n+\t\t\tlog.WithError(err).Error(\"Failed to connect to Typha. Retrying...\")\n+\t\t\tstartTime := time.Now()\n+\t\t\tfor err != nil && time.Since(startTime) < 30*time.Second {\n+\t\t\t\t// Set Ready to false and Live to true when unable to connect to typha\n+\t\t\t\thealthAggregator.Report(healthName, &health.HealthReport{Live: true, Ready: false})\n+\t\t\t\terr = typhaConnection.Start(context.Background())\n+\t\t\t\tlog.WithError(err).Debug(\"Retrying to start Typha\")\n+\t\t\t\ttime.Sleep(1 * time.Second)\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tlog.WithError(err).Fatal(\"Failed to connect to Typha\")\n+\t\t\t}\n \t\t}\n \t\tgo func() {\n \t\t\ttyphaConnection.Finished.Wait()\nCode Quality Aspect: expressions\nReview:"}
